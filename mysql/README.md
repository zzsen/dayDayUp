## 事务

### 特性ACID

关系性数据库需要遵循ACID规则, 具体内容如下：

1. 原子性 atomicity：

   要么全部提交成功, 要么全部失败回滚

2. 一致性 consistency：

   事务执行前后, 数据库都必须处于一致性状态

3. 隔离性 isolation：

   一个事务所做的修改在最终提交以前, 对其他事务是不可见的

4. 持久性 durability：

   事务提交后, 对数据的改变是持久的, 即使数据库发生故障也不对其有任何影响。

### 4个隔离级别

1. 读未提交 Read Uncommitted

   **隔离级别最低**

   事务中的修改, 即使没有提交, 对其他事务也都是可见的

2. 读已提交 Read Committed

   **大多数数据库的默认隔离级别**

   事务一旦提交, 该事务所作的修改对其他正在进行中的事务就是可见的。

3. 可重复读 Repeatable Read

   **MySQL的默认隔离级别**

   同一个事务中多次读取同样记录结果是一致的

4. 可序列化 Serializable

   **隔离级别最高**

   事务只能串行执行, 不能并发执行

### 如果不考虑隔离性, 会发生什么事呢？

1. 脏读
   事务可以读取未提交的数据, 而该数据可能在未来因回滚而消失
   
2. 不可重复读
	事务内的多次查询却返回了不同的结果, 这是由于在查询过程中, 数据被另外一个事务修改并提交了。
	
3. 幻读
   事务在读取目标范围内的记录时, 另一个事务又在该范围内插入了新的记录, 当之前的事务再次读取该范围的记录时, 会产生第一次读取范围时不存在的幻行
   
   
### 总结

| 隔离级别/能解决的问题 | 脏读 | 不可重复读 | 幻读 |
| --------------------- | ---- | ---------- | ---- |
| 读未提交              | -    | -          | -    |
| 读已提交              | Y    | -          | -    |
| 可重复读              | Y    | Y          | -    |
| 可序列化              | Y    | Y          | Y    |

   不可重复读和幻读比较相似, 区别在于:
   1. 解决**不可重复读**的方法是 **锁行**, 解决**幻读**的方式是 **锁表**。
   2. **不可重复读**  读到其他事务**update/delete**后已提交的数据
      **幻读** 读到其他事务**insert**已经提交的数据

## 锁

## 索引

## 日志

### 日志类型

* redo log

* undo log

* binlog

* errorlog 

* slow query log

* general log

* relay log

### 谈谈redo log 、 undo log 和 binlog的异同

#### 1. 实现层级

   * **binlog**是mysql**服务层**实现的

   * **redolog**和**undolog**是**引擎层**实现的, **只存在于innodb中**, 统称为事务日志, myisam引擎并没有实现

#### 2. 用途
* redo log
   **确保事务的持久性**
   
   
   
* undo log
	* **用于回滚**
	* **MVCC**	
  
	
	
* binlog
	* **复制**：MySQL Replication在Master端开启binlog, Master把它的二进制日志传递给slaves并回放来达到master-slave数据一致的目的
	* **数据恢复**：通过mysqlbinlog工具恢复数据
	* **增量备份**

#### 3.存储内容、格式
   * redo log
     **物理日志**
     
     
     
   * undo log
     **逻辑日志**
     
  * binlog
     **逻辑日志**
     
     

#### 4. 生命周期
* redolog
  **事务开始之后**, 就开始产生 redo log 日志了
  
* undolog
	**事务开始之前**, 将当前事务版本生成 undo log
	
* binlog
	**事务提交的时候**, 一次性将事务中的 所有sql 语句按照一定的格式记录到 binlog 中

### 两阶段提交
   将数据页加载到内存 → 修改数据 → 更新数据 → **写redolog（状态为prepare）** → 写binlog → **提交事务**（**数据写入成功后将redo log状态改为commit**）

### redo log 刷盘
[redo log 刷盘](./redolog_undolog.md)
### 其他相关文档建议

[浅谈mysql日志系统](https://blog.csdn.net/zzsan/article/details/118397623)

[腾讯工程师带你深入解析 MySQL binlog](https://zhuanlan.zhihu.com/p/33504555)

[详细分析MySQL事务日志(redo log和undo log)](https://www.cnblogs.com/f-ck-need-u/p/9010872.html)



## MyISAM 和 InnoDB

1. **存储结构**

   * MyISAM：存储成三个文件。.frm文件存储表定义。数据文件的扩展名为.MYD (MYData)。索引文件的扩展名是.MYI (MYIndex)。
   * InnoDB：所有表保存在同一个数据文件中（也可能是多个文件, 或者是独立的表空间文件）, InnoDB表大小只受限于操作系统文件的大小, 一般为2GB。

2. **存储空间**

   * MyISAM：可被压缩, 存储空间较小。支持三种不同的存储格式：静态表、动态表、压缩表。
   * InnoDB：需要更多内存和存储, 会在主内存中建立其专用的缓冲池用于高速缓冲数据和索引。

3. **事务支持**

   InnoDB 支持事务, MyISAM 不支持事务

4. **AUTO_INCREMENT**
   * MyISAM：**可以和其他字段一起建立联合索引**。引擎的自动增长列必须是索引, 如果是组合索引, 自动增长可以不是第一列, 他可以根据前面几列进行排序后递增。
   * InnoDB：**必须包含只有该字段的索引**。引擎的自动增长列必须是索引, 如果是组合索引也必须是组合索引的第一列。
   
5. **外键**

   InnoDB 支持外键, MyISAM 不支持

6. **表锁差异**

   * MyISAM：**只支持表级锁**, 用户在操作时, update, insert语句都会给表自动加锁
   * InnoDB：**支持事务和行级锁**。行锁大幅度提高了并发操作的性能。但是InnoDB的行锁, 只是在WHERE的主键是有效的, **非主键的WHERE都会锁全表的**。

   > MyISAM一个更新语句会锁住整张表, 导致其他查询和更新都会被阻塞, 因此并发访问受限

7. **全文索引**

   InnoDB不支持FULLTEXT类型的全文索引, MyISAM支持 FULLTEXT类型的全文索引

8. **表主键**

   * MyISAM：允许没有任何索引和主键的表存在, 索引都是保存行的地址。
   * InnoDB：如果没有设定主键或者非空唯一索引, **就会自动生成一个6字节的主键(用户不可见)**, 数据是主索引的一部分, 附加索引保存的是主索引的值。

9. **InnoDB 是聚集索引, MyISAM 是非聚集索引**

   聚簇索引的文件存放在主键索引的叶子节点上, 因此 InnoDB 必须要有主键, 通过主键索引效率很高。但是辅助索引需要两次查询, 先查询到主键, 然后再通过主键查询到数据。因此, 主键不应该过大, 因为主键太大, 其他索引也都会很大。而 MyISAM 是非聚集索引, 数据文件是分离的, 索引保存的是数据文件的指针。主键索引和辅助索引是独立的。

10. **表的具体行数**
      InnoDB 不保存表的具体行数, MyISAM 用一个变量保存了整个表的行数
    
     >InnoDB 不保存表的具体行数, 执行 select count(*) from table 时需要全表扫描。MyISAM 用一个变量保存了整个表的行数, 执行上述语句时只需要读出该变量即可


## mysql中, datetime 和 timestamp
### 共同点
1. 都可用于表示`YYYY-MM-DD HH:MM:SS`类型的日期。

### 不同点
1. 存储方式

   * `timestamp` 是以`utc`的格式储存,  它会自动检索当前时区并进行转换。

   * `datetime`不会进行时区的检索.

   > 即: 对于`timestamp`, 如果储存时的时区和检索时的时区不一样, 那么拿出来的数据也不一样。对于`datetime`, 存什么拿到的就是什么。

   > 还有一个区别就是如果存进去的是`NULL`, `timestamp`会自动储存当前时间, 而 `datetime`会储存 `NULL`。

2. 能存储的时间范围

   * timestamp：`'1970-01-01 00:00:01.000000'` 到 `'2038-01-19 03:14:07.999999'`。
   
   * datetime：`'1000-01-01 00:00:00.000000'` 到 `'9999-12-31 23:59:59.999999'`。

3. 占用空间
   * datetime: 8 字节
   * timestamp: 4 字节


## 其他基础知识
[索引基本知识](./index_base.md)
> 索引分类, 创建和使用, 最左前缀匹配

[ddl、dml和dql](./ddl_dml_dql.md)

## 进阶知识
[mysql with 的用法 (含 with recursive)](./with_statement.md)
>递归CTE

[MySQL in和exists查询对比](./in_exists.md)

[explain执行计划](./explain.md)
> explain用途, 字段说明

[mysql索引原理](./index_theory.md)
>索引数据结构, 回表, 覆盖索引, 索引下推优化