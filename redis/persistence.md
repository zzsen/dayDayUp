
## redis持久化
Redis是一个基于内存的非关系型的数据库，数据保存在内存中，但是内存中的数据也容易发生丢失。

Redis提供了持久化的机制，分别是 **RDB(Redis DataBase)** 和 **AOF(Append Only File)** 。


### RDB
RDB持久化就是将当前进程的数据以**生成快照**的形式持久化到磁盘中。


RDB持久化的时候会**单独fork一个子进程**来进行持久化，不会阻塞主进程。由于RDB文件是紧凑的二进制快照，因此具有如下特点：
1. 开机恢复数据快。

2. 写入持久化文件快。

RDB的持久化也是Redis默认的持久化机制，它会把内存中的数据以快照的形式写入默认文件名为`dump.rdb`中保存。

#### COW（Copy-On-Write）机制
bgsave通过fork创建子进程时，并不会立即复制一份完整的内存数据，而是利用操作系统的**写时复制（COW）**机制：

1. `fork()`是操作系统内核级别的**原子操作**，调用完成的瞬间，子进程获得父进程**完整的页表副本**，父子进程共享同一批物理内存页，此时内存占用几乎不增加。
2. fork之后，父进程继续处理客户端写请求。当父进程需要修改某块内存页时，操作系统会**先将该页复制一份新页给父进程修改**，而子进程的页表**仍然指向原始的、未被修改的旧页**。
3. 因此，父进程的写操作对子进程**完全不可见**，子进程从头到尾读到的都是fork那一刻的完整数据，不会出现"部分 key 是新值、部分 key 是旧值"的情况，从而保证了**快照的数据一致性**。

bgsave的额外内存消耗取决于fork之后父进程的**写操作量**（即有多少页被COW复制），而非整个数据集大小。在写操作较少的场景下，额外内存开销很小。

#### COW 示例

**情况一：修改已有 key**

假设 bgsave 触发前，内存中已有 `keyA = oldValue`，fork 之后父进程收到 `set keyA newValue`：

```
时间线：
    内存中已有 keyA = oldValue
             │
    bgsave触发 → fork（原子操作，父子进程共享同一批内存页）
             │
  父进程：    ├── 收到 set keyA newValue → 触发COW
             │     OS复制该页 → 父进程在新页上改为 newValue
             │                → 子进程仍指向旧页，看到的是 oldValue
             │
  子进程：    └── 遍历内存写RDB → 读到 keyA = oldValue → 写入RDB → 退出
```

子进程能看到 keyA，但值是 fork 那一刻的 **oldValue**，不是新写入的 newValue。

**情况二：新增 key**

假设 bgsave 触发前，内存中不存在 keyB，fork 之后父进程收到 `set keyB valueB`：

```
时间线：
    内存中没有 keyB
             │
    bgsave触发 → fork（原子操作，父子进程共享同一批内存页）
             │
  父进程：    ├── 收到 set keyB valueB → 在自己的新页中写入keyB
             │     子进程的页表中没有这个新页的映射
             │
  子进程：    └── 遍历内存写RDB → 没有keyB → RDB中不包含keyB → 退出
```

子进程完全看不到 keyB，RDB 文件中也不会有。

**结论：子进程只能看到 fork 那一刻已经存在的数据和当时的值**，fork 之后父进程的所有写入（无论新增还是修改）对子进程都不可见。fork 之后的数据不会丢失，它们保留在父进程的内存中，等下一次持久化时再写入。

#### 持久化触发时机
在RDB机制中触发内存中的数据进行持久化，有以下三种方式：
1. save命令：

    save命令**不会fork子进程**，通过**阻塞当前Redis服务器**，直到RDB完成为止，所以该命令在生产中一般不会使用。

2. bgsave命令：

    bgsave命令会**在后台fork一个与Redis主进程一模一样的子进程，由子进程负责内存中的数据持久化**。
    这样fork与主进程一样的子进程消耗了内存，但是不会阻塞主进程处理客户端请求，是**以空间换时间**的方式快照内存中的数据到文件中。
    bgsave命令阻塞只会发生在fork子进程的时候，这段时间发生的非常短，可以忽略不计

3. 自动化

    除了上面在命令行使用save和bgsave命令触发持久化，也可以在redis.conf配置文件中，完成配置，如下所示
    ```
    ################################ SNAPSHOTTING  ################################
    # Save the DB on disk:
    #   save <seconds> <changes>

    #   after 900 sec (15 min) if at least 1 key changed
    save 900 1
    #   after 300 sec (5 min) if at least 10 keys changed
    save 300 10
    #   after 60 sec if at least 10000 keys changed
    save 60 10000
    ```

##### save和bgsave的对比区别
1. save是同步持久化数据，而bgsave是异步持久化数据。
2. save不会fork子进程，通过主进程持久化数据，会阻塞处理客户端的请求，而bgsave会fork子进程持久化数据，同时还可以处理客户端请求，高效。
3. save不会消耗内存，而bgsave会消耗内存

#### RDB的优缺点
##### 缺点
1. 如果要尽量避免丢失数据, 则RDB不适合
	>在生成快照的间隔中, 如果发生异常停机, 期间的数据就会丢失
2. 每次RDB时, 都需要fork一个子进程, 由子进程进行持久化, 数据集较大时, fork可能会比较耗时, 造成服务器在一段时间内停止处理客户端请求

##### 优点
1. RDB是一个文件, 保存了某个时间点的数据集
	> 例如, 可以每个小时备份一个rdb文件, 遇到问题可以随时回退到对应时间点

2. 非常适用于灾难恢复
	>只有一个文件, 而且内容紧凑, 可以(加密后)传输到其他服务器, 然后恢复服务

3. 最大化redis性能, 父进程在保存RDB文件时, 唯一要做的就是fork一个子进程, 然后剩下的工作都由子进程处理, 父进程无需处理任何的磁盘I/O操作

4. RDB在恢复大数据集时, 速度要优于AOF

### AOF
AOF是**以日志的形式记录Redis中的每一次的增删改操作**，不会记录查询操作，以文本的形式记录，打开记录的日志文件就可以查看操作记录。**默认不开启AOF**

#### AOF触发机制
AOF带来的持久化更加安全可靠，默认提供三种触发机制，如下所示：

1. `no`：表示由操作系统决定何时将数据缓存同步到磁盘中（快、持久化没保证）。

2. `always`：同步持久化，每次发生数据变更时，就会立即记录到磁盘中（慢，安全）。

3. `everysec`：表示每秒同步一次（默认值，很快，但是会丢失一秒内的数据）。

```
# appendfsync always
appendfsync everysec
# appendfsync no
```

AOF中每秒同步是**异步**完成的，**效率很高**，由于该机制对日志文件的写入操作是采用append的形式, 因此在写入时即使宕机，也不会丢失已经存入日志文件的数据，数据的完整性是非常高的。


#### AOF重写机制
写入所有操作到日志文件时，会出现很多重复操作，甚至无效操作(如: 先i++, 再i--)，导致日志文件越来越大。记录的文件臃肿，就浪费了资源空间，所以Redis提供了rewrite机制。

redis提供了`bgrewriteaof`命令。将内存中的数据以命令的方式保存到临时文件中，同时会fork出一个子进程来将文件重写。

重写AOF的日志文件不是读取旧的日志文件瘦身，而是将内存中的数据用命令的方式重写一个AOF文件，重新保存替换原来旧的日志文件，因此内存中的数据才是最新的。

重写操作也会**fork一个子进程来处理重写操作**，重写以内存中的数据作为重写的源，避免了操作的冗余性，保证了数据的最新。

在Redis以append的形式将修改的数据写入旧的AOF文件中，同时Redis也会创建一个新的文件用于记录此期间有哪些命令被执行。


#### AOF重写运作方式
1. redis执行fork一个子进程
2. AOF文件内容写进临时文件
3. 父进程一边把写入指令累积到内存缓存, 一边将这些改动追加到AOF文件末尾
4. 子进程开始重写工作, 完成后, 给父进程发送信号, 父进程收到信号后, 把内存缓存的数据追加到新AOF的末尾
#### AOF的优缺点
##### 优点
1. **可靠性较高**, AOF更好保证数据不会被丢失，最多只丢失一秒内的数据
2. 通过fork一个子进程处理持久化操作，保证了主进程不会进行IO操作，能高效的处理客户端的请求。
3. 另外重写操作保证了数据的有效性，即使日志文件过大也会进行重写。

4. **可读性高**, 即使某一时刻有人执行flushall清空了所有数据，只需要拿到aof的日志文件，然后把最后一条的flushall给删除掉，就可以恢复数据。

##### 缺点
对于相同数量的数据集而言，AOF文件通常要大于RDB文件。RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快。AOF在运行效率上往往会慢于RDB。

### RDB vs AOF 对比

| 对比项 | RDB | AOF |
| --- | --- | --- |
| 持久化方式 | 某一时刻的全量数据快照 | 记录每一次写操作命令 |
| 文件体积 | 小（二进制紧凑格式） | 大（文本命令格式，即使重写后通常也比RDB大） |
| 恢复速度 | 快（直接加载二进制数据） | 慢（需要逐条重放命令） |
| 数据安全性 | 低（两次快照之间的数据可能丢失） | 高（最多丢失1秒数据，`always`模式下几乎不丢失） |
| 对性能的影响 | fork时有短暂阻塞，之后无影响 | 写操作需要追加日志，`always`模式影响较大 |
| 文件可读性 | 不可读（二进制格式） | 可读（Redis命令文本） |
| 默认开启 | 是 | 否 |

### 混合持久化（Redis 4.0+）

Redis 4.0 引入了**混合持久化**模式，结合了RDB和AOF各自的优点。通过配置开启：

```
aof-use-rdb-preamble yes
```

#### 工作原理
在AOF重写时，子进程不再将内存数据转换为命令写入AOF文件，而是：

1. 先将当前内存数据以**RDB格式**写入新AOF文件的**前半部分**。
2. 重写期间，父进程新收到的写命令仍以**AOF格式**追加到新AOF文件的**后半部分**。

最终生成的AOF文件 = RDB头 + AOF尾。

#### 优点
1. **恢复速度快**：加载时先读取RDB部分快速恢复大量数据，再重放少量AOF命令。
2. **数据安全性高**：结合了AOF只丢失少量数据的优势。

#### 缺点
1. AOF文件中的RDB部分不再可读，降低了可读性。
2. 兼容性问题：混合格式的AOF文件不能在 Redis 4.0 之前的版本使用。

### 数据恢复优先级

当RDB和AOF同时开启时，Redis重启后的数据恢复遵循以下优先级：

1. **优先加载AOF文件**，因为AOF的数据完整性通常高于RDB。
2. 只有当AOF未开启时，才会加载RDB文件。
3. 如果AOF文件存在但损坏，Redis会启动失败，可使用`redis-check-aof`工具修复。

```
                     启动Redis
                        │
                   AOF是否开启？
                   /          \
                 是             否
                 │              │
           AOF文件是否存在？   加载RDB文件
           /          \
         是             否
         │              │
    加载AOF文件      加载RDB文件
```

### 相关链接
[浅谈redis持久化](https://blog.csdn.net/zzsan/article/details/119391466)
