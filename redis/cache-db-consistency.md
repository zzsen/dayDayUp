
## 数据库和缓存双写一致性
### 对于读请求的处理
1. 先读cache, 再读db

2. 如果, cache hit, 则直接返回数据

3. 如果, cache miss, 则访问db, 并将数据set回缓存

### 更新策略
写操作, 既要操作数据库中的数据, 又要操作缓存里的数据。
因此, 有以下两个方案:
1. 先操作数据库, 再操作缓存

2. 先操作缓存, 再操作数据库

操作缓存可以分为更新缓存和删除缓存, 故原来的两个方案可以细化为4个方案

1. 先操作数据库, 再删除缓存

2. 先删除缓存, 再操作数据库

3. 先操作数据库, 再更新缓存

4. 先更新缓存, 再操作数据库

### 1. 先操作数据库, 再删除缓存
Cache-Aside pattern 原则:

**失效**：应用程序先从cache取数据, 没有得到, 则从数据库中取数据, 成功后, 放到缓存中。

**命中**：应用程序从cache中取数据, 取到后返回。

**更新**：先把数据存到数据库中, 成功后, 再让缓存失效。

假设有两个请求, 请求A做查询操作, 请求B做更新操作, 那么会有如下情形产生
1) 缓存刚好失效
2) 请求A查询数据库, 得一个旧值
3) 请求B将新值写入数据库
4) 请求B删除缓存
5) 请求A将查到的旧值写入缓存
ok, 如果发生上述情况, 确实是会发生脏数据。

然而, 发生这种情况的概率并不高

发生上述情况有一个先决条件, 就是步骤3的写数据库操作比步骤2的读数据库操作耗时更短, 才有可能使得步骤4先于步骤5。可是, 数据库的读操作的速度远快于写操作的（不然做读写分离干嘛, 做读写分离的意义就是因为读操作比较快, 耗资源少）, 因此步骤3耗时比步骤2更短, 这一情形很难出现。

此外, 如果缓存删除失败, 可以引入消息队列, 应用程序自己消费消息(消息里是要删除的key), 重试删除缓存, 直至成功 

### 2. 先删除缓存, 再操作数据库
假设A、B两个线程
1) 请求A进行写操作, 删除缓存
2) 请求B查询发现缓存不存在
3) 请求B去数据库查询得到旧值
4) 请求B将旧值写入缓存
5) 请求A将新值写入数据库


为了避免这个情况, 可以使用**延时双删策略**

即:
1) 先淘汰缓存
2) 再写数据库
3) 休眠, 再次淘汰缓存

休眠时间在读数据的耗时的基础上加几百ms, 如果有主从同步延时, 则睡眠时间修改为在主从同步的延时时间基础上, 加几百ms

### 3. 先操作数据库, 再更新缓存
从线程安全考虑:
假设A、B两个线程
1) A先更新数据库
2) B再更新数据库
3) B先更新缓存
4) A后更新缓存
这样就导致数据库是最新的数据, 但是缓存中是旧的脏数据。

从实际场景上考虑
1) 如果写数据库场景比较多, 而读数据场景比较少, 采用这种方案就会导致, 数据还没读到, 缓存被频繁的更新, 浪费性能。
2) 如果写入数据库的值, 不是直接写入缓存的, 而是要经过计算再写入缓存(如, 类型转换, 序列化等)。那么, 每次写入数据库后, 都再次计算写入缓存的值, 无疑是浪费性能的。此时, 删除缓存更为适合。

### 4. 先更新缓存, 再操作数据库

假设A、B两个线程
1) A先更新缓存
2) B再更新缓存
3) B先更新数据库
4) A后更新数据库
这样就导致缓存是最新的数据, 但是数据库中是旧的脏数据。

另外, 如果更新数据库失败, 则缓存里的数据就是脏数据了


### 四种策略对比

| 策略 | 一致性风险 | 发生概率 | 推荐程度 |
| --- | --- | --- | --- |
| 1. 先操作数据库, 再删除缓存 | 缓存短暂不一致（读写并发时） | 极低 | ⭐⭐⭐⭐⭐ 推荐 |
| 2. 先删除缓存, 再操作数据库 | 缓存脏数据（读写并发时） | 较高 | ⭐⭐⭐ 需配合延时双删 |
| 3. 先操作数据库, 再更新缓存 | 缓存脏数据（写写并发时） | 较高 | ⭐⭐ 不推荐 |
| 4. 先更新缓存, 再操作数据库 | 数据库脏数据 + DB失败导致缓存脏数据 | 较高 | ⭐ 不推荐 |

**结论：推荐使用策略 1（Cache-Aside 模式）**，出现不一致的概率极低，且可配合补偿机制进一步保障。

### 缓存删除失败的补偿机制

策略 1 的主要风险在于**删除缓存失败**，导致缓存中一直是旧数据。有两种补偿方案：

#### 方案一：消息队列重试

```
更新数据库 → 删除缓存 → 失败？→ 发送消息到MQ → 消费者重试删除 → 直至成功
```

缺点：对业务代码有**侵入性**，需要在业务逻辑中耦合消息发送的代码。

#### 方案二：订阅数据库 binlog

利用 Canal 等中间件**监听数据库的 binlog 变更**，自动触发缓存删除，无需修改业务代码。

```
                        ┌─────────────┐
业务代码 ──── 更新DB ──→ │  MySQL主库   │
                        └──────┬──────┘
                               │ binlog
                        ┌──────▼──────┐
                        │    Canal    │
                        └──────┬──────┘
                               │ 解析变更
                        ┌──────▼──────┐
                        │   MQ/消费者  │
                        └──────┬──────┘
                               │ 删除缓存
                        ┌──────▼──────┐
                        │    Redis    │
                        └─────────────┘
```

优点：
1. **对业务代码无侵入**，业务只需要操作数据库。
2. **可靠性高**，binlog 本身是数据库的持久化日志，不会丢失。
3. 天然适配**读写分离**场景，可以订阅从库的 binlog，在从库同步完成后再删缓存。

### 关于一致性级别

上述所有方案都只能保证**最终一致性**，无法做到强一致性。在分布式系统中，缓存和数据库是两个独立的数据源，无法通过单一事务同时原子地更新两者。

如果业务对一致性要求极高（如金融场景），可以考虑：
1. **不使用缓存**，直接读数据库。
2. **加分布式锁**，将读写操作串行化，但会严重影响性能。
3. **设置较短的缓存过期时间**，作为兜底策略，即使出现不一致也能在短时间内自动恢复。

在大多数业务场景下，**Cache-Aside + 合理的缓存过期时间**已经能满足需求。

### 参考文档
双写一致性部分摘抄自 [分布式之数据库和缓存双写一致性方案解析](https://zhuanlan.zhihu.com/p/48334686)
