
## 缓存穿透、缓存击穿、缓存雪崩

### 三者对比

| 对比项 | 缓存穿透 | 缓存击穿 | 缓存雪崩 |
| --- | --- | --- | --- |
| 核心区别 | 数据**根本不存在** | **单个**热点key过期 | **大量**key同时过期或缓存服务宕机 |
| 请求特征 | 查询的是不存在的数据 | 高并发集中访问同一个key | 大量请求同时失去缓存保护 |
| 影响范围 | 特定的非法请求 | 单个热点数据 | 大面积缓存失效 |
| 典型解决方案 | 布隆过滤器、缓存空对象 | 互斥锁、永不过期 | 随机过期时间、高可用部署、降级熔断 |

### 缓存穿透
查询**一定不存在的数据**, 因为查不到数据所以也不会写入缓存, 所以每次都会查询数据存储, 导致数据存储压力过大。
#### 解决方案
* 由于请求的参数是不合法的(每次都请求不存在的参数), 可以使用布隆过滤器(BloomFilter)或者压缩filter提前拦截, 不合法就不让这个请求到数据库层
* 从数据库找不到时, 也缓存空对象, 即: 将key-value对写为key-null。
  >这种情况一般会将空对象设置一个较短的过期时间。

### 缓存击穿
高并发下, **当某个缓存失效时, 可能出现多个进程同时查询数据存储**, 导致数据存储压力过大。

#### 解决方案
* 设置热点数据永远不过期。

* 使用互斥锁(mutex key)
  >比较常用的做法, 是使用mutex。就是在缓存失效的时候（判断拿出来的值为空）, 不是立即去查数据库, 而是先使用缓存工具的某些带成功操作返回值的操作（比如Redis的SETNX或者Memcache的ADD）去set一个mutex key, 当操作返回成功时, 再进行查数据库的操作并回设缓存; 否则, 就重试整个get缓存的方法。


### 缓存雪崩
高并发下, **大量缓存同时失效**或**缓存服务宕机**, 导致大量请求同时查询数据存储, 导致数据存储压力过大。

#### 解决方案
* 设置热点数据永远不过期

* 使用多级缓存机制, 比如同时使用redis和memcache缓存, 请求->redis->memcache->db

* 用加锁或者队列的方式来保证不会有大量的线程对数据库一次性进行读写, 从而避免失效时大量的并发请求落到底层存储系统上
  >加锁排队只是为了减轻数据库的压力, 并没有提高系统吞吐量。假设在高并发下, 缓存重建期间key是锁着的, 这时过来的大部分请求都是阻塞的。会导致用户等待超时

* 将缓存失效时间分散开, 比如可以在原有的失效时间基础上增加一个随机值, 比如1-5分钟随机, 这样缓存过期时间的重复率就会降低, 就很难引发集体失效的事件。

* **Redis高可用部署**，使用 Sentinel（哨兵）或 Cluster（集群）模式，避免单点故障导致整个缓存层不可用。

* **服务降级与熔断**，当检测到数据库压力过大时，暂时降级非核心业务的缓存查询（如返回默认值或友好提示），防止数据库被压垮。可结合 Hystrix、Sentinel 等熔断组件实现。
