# 内存逃逸

在 Go 语言中，内存逃逸指的是一个变量被分配在堆上而不是栈上。如果一个变量逃逸到堆上，则意味着它在函数返回后仍然存在，并且可能需要垃圾回收器来回收它的内存。这可能会导致性能问题和内存泄漏。

Go 编译器会尝试在栈上分配变量，以提高性能。但是，如果变量在函数返回后仍然被引用，编译器将不得不在堆上分配它。这种情况下，编译器会引发一个“内存逃逸”错误，提示您需要优化代码以避免在堆上分配变量。

**一个对象本应该分配在栈上面，结果分配在了堆上面，这就是内存逃逸**

- Golang 的 GC 主要是针对堆的，不是栈。
- 引用类型的全局变量分配在堆上，值类型的全局变量分配在栈上。
- 局部变量内存分配可能在栈上也可能在堆上。

## 内存逃逸场景及分析

执行`go build -gcflags=-m main.go`, 可分析内存逃逸情况

### 1. 局部指针返回

当函数的返回值为函数内局部变量的指针时, 函数返回后, 该指针仍需被外部引用, 故其生命周期大于栈, 只能分配到堆上, 导致内存溢出

```go
package main

func escape1() *int {
	var a int = 1
	return &a
}
func main() {
	escape1()
}
// # command-line-arguments
// .\main.go:3:6: can inline escape1
// .\main.go:7:6: can inline main
// .\main.go:8:9: inlining call to escape1
// .\main.go:4:6: moved to heap: a
```

### 2. 动态类型逃逸

编译期间不确定参数的类型、参数的长度也不确定的情况下就会发生逃逸

```go
package main

import "fmt"

func main() {
	fmt.Println("dayDayUp")
}
// # command-line-arguments
// .\main.go:5:6: can inline main
// .\main.go:6:13: inlining call to fmt.Println
// .\main.go:6:13: ... argument does not escape
// .\main.go:6:14: "dayDayUp" escapes to heap
```

分析: fmt.Println 源码如下:

```go
// type any = interface{}

// Println formats using the default formats for its operands and writes to standard output.
// Spaces are always added between operands and a newline is appended.
// It returns the number of bytes written and any write error encountered.
func Println(a ...any) (n int, err error) {
	return Fprintln(os.Stdout, a...)
}
```

### 3. 返回接口

```go
package main

type Man interface {
	Show()
}

type User struct {
}

func (user User) Show() {
}

func NewMan() (man Man) {
	user := User{}
	man = user
	return
}

func main() {
}
// # command-line-arguments
// .\main.go:10:6: can inline User.Show
// .\main.go:13:6: can inline NewMan
// .\main.go:19:6: can inline main
// .\main.go:15:2: user escapes to heap
// <autogenerated>:1: inlining call to User.Show
```

Newman 中有一个 user 到接口 man 的转换。
go 同的接口由动态值和动态类型两部分构成，man 中的动态值指针，指向了 user(更准备的说应该是 user 的拷贝)对应的内存，这部分是可能在函数返回后会用到的，所以只能分配在堆上。

### 4. 栈空间不足逃逸

当栈空间不足以存放当前对象时, 会将对象分配到堆中。

```go
package main

func escape() {
	s := make([]int, 0, 8193)
	for index, _ := range s {
		s[index] = index
	}
}
func noEscape() {
	s := make([]int, 0, 8192)
	for index, _ := range s {
		s[index] = index
	}
}
func main() {
}
// # command-line-arguments
// .\main.go:3:6: can inline escape
// .\main.go:9:6: can inline noEscape
// .\main.go:15:6: can inline main
// .\main.go:4:11: make([]int, 0, 8193) escapes to heap
// .\main.go:10:11: make([]int, 0, 8192) does not escape
```

### 5. 闭包引用对象逃逸

闭包函数中局部变量在后续函数是继续使用的，编译器将其分配到堆上

```go
package main

func main() {
 f := fibonacci()
 for i := 0; i < 10; i++ {
  f()
 }
}
func fibonacci() func() int {
 a, b := 0, 1
 return func() int {
  a, b = b, a+b
  return a
 }
}
// # command-line-arguments
// .\main.go:9:6: can inline fibonacci
// .\main.go:11:9: can inline fibonacci.func1
// .\main.go:4:16: inlining call to fibonacci
// .\main.go:11:9: can inline main.func1
// .\main.go:6:4: inlining call to main.func1
// .\main.go:4:16: func literal does not escape
// .\main.go:10:2: moved to heap: a
// .\main.go:10:5: moved to heap: b
// .\main.go:11:9: func literal escapes to heap
```

### 6. 变量大小不确定

```go
package main

func escape() {
	// 逃逸
	number := 10
	s := make([]int, number)
	for i := 0; i < len(s); i++ {
		s[i] = i
	}
}
func noEscape() {
	// 不逃逸
	s := make([]int, 10)
	for i := 0; i < len(s); i++ {
		s[i] = i
	}
}
func main() {
}
// # command-line-arguments
// .\main.go:3:6: can inline escape
// .\main.go:10:6: can inline noEscape
// .\main.go:16:6: can inline main
// .\main.go:5:11: make([]int, number) escapes to heap
// .\main.go:11:11: make([]int, 10) does not escape
```

编译期无法确定 slice 的长度，这种情况为了保证内存的安全，编译期也会触发逃逸，在堆上进行内存分配

## 内存逃逸结果分析
### 1. 内存分配在堆和栈的区别

* 如果分配在栈中，则函数执行结束可自动将内存回收；
* 如果分配在堆中，则函数执行结束交给 GC（垃圾回收）处理;

### 2. 带来的问题
过多的内存逃逸，会使更多的内存分配在堆上，导致GC压力过大，影响代码运行效率。
